# 4. ğŸ“¦ Repository i controlador per a equips

En aquesta part volem que entengueu **quÃ¨ estem fent** quan afegim:

- una **interface** (`BaseRepository`)
- un **repository** (`EquipRepository`)
- un **service** (`EquipService`)
- i el registre al **ServiceProvider**

Ho separem en dos blocs:

1. ExplicaciÃ³ **conceptual** (sense Laravel).  
2. AplicaciÃ³ **concreta a la prÃ ctica** del projecte.

---

## 1ï¸âƒ£ Idea general: quÃ¨ sÃ³n Repository, Interface, Service i ServiceProvider?

### ğŸ¯ Quin problema intentem resoldre?

El flux â€œsimpleâ€ seria:

```php
class EquipController extends Controller {
    public function index() {
        $equips = Equip::all();
        // mÃ©s lÃ²gica...
    }

    public function store(Request $request) {
        Equip::create($request->all());
        // mÃ©s coses...
    }
}
```

AixÃ², en un projecte xicotet, **funciona**. 
PerÃ² quan el projecte creix:

- El controller acaba amb **moltes lÃ­nies**. 
- Barregem:
  - HTTP (peticions/respostes),
  - lÃ²gica de negoci,
  - accÃ©s a base de dades (Eloquent/SQL).

I tot aixÃ² barrejat en un Ãºnic fitxer es fa:

- difÃ­cil de llegir, 
- difÃ­cil de provar, 
- difÃ­cil de mantindre.

### ğŸ§± SoluciÃ³: separar responsabilitats

Afegim capes intermitges:

```text
Controller â†’ Service â†’ Repository â†’ Model (Eloquent) â†’ BBDD
```

- El **Controller**:
  - rep la peticiÃ³ (GET/POST/PUT/DELETE),
  - demana al *service* que faÃ§a la feina,
  - envia les dades a la vista o redirigeix.

- El **Service**:
  - contÃ© la **lÃ²gica de negoci**:
    - â€œquÃ¨ sâ€™ha de ferâ€ amb les dades,
    - regles, comprovacions, etc.
  - utilitza un *repository* per accedir a la BBDD.

- El **Repository**:
  - Ã©s el que sap **com** es parla amb la BBDD (Eloquent).
  - concentra les consultes per a un model concret (`Equip` en el nostre cas).

---

### ğŸ§© QuÃ¨ Ã©s una *Interface* (`BaseRepository`)?

Una **interface** Ã©s un **contracte**: diu quins mÃ¨todes ha de tindre una classe, perÃ² no diu el codi.

Exemple senzill:

```php
interface Animal {
    public function ferSo();
}
```

Qualsevol classe que implemente `Animal` haurÃ  de tindre un mÃ¨tode `ferSo()`:

```php
class Gos implements Animal {
    public function ferSo() { echo "Bup!"; }
}

class Gat implements Animal {
    public function ferSo() { echo "Miau!"; }
}
```

El codi que rep un `Animal` **no sap** si Ã©s gos o gat, perÃ² sap que pot cridar `ferSo()`.

En el nostre cas:

```php
interface BaseRepository {
    public function getAll();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}
```

TraduÃ¯t:

> Qualsevol *repository* que implemente `BaseRepository`
> ha de tindre almenys aquests mÃ¨todes: `getAll`, `find`, `create`, `update`, `delete`.

Encara **no hi ha cap consulta Eloquent** acÃ­, nomÃ©s la forma dels mÃ¨todes.

---

### ğŸ“¦ QuÃ¨ Ã©s un *Repository* (`EquipRepository`)?

El **repository** Ã©s qui sâ€™encarrega dâ€™anar a la BBDD per a un model concret.

Per exemple, per a `Equip`:

```php
class EquipRepository implements BaseRepository {
    public function getAll() {
        return Equip::all();
    }

    public function find($id) {
        return Equip::findOrFail($id);
    }

    public function create(array $data) {
        return Equip::create($data);
    }

    public function update($id, array $data) {
        $equip = Equip::findOrFail($id);
        $equip->update($data);
        return $equip;
    }

    public function delete($id) {
        return Equip::destroy($id);
    }
}
```

AcÃ­ **sÃ­** tenim codi dâ€™Eloquent:

- `Equip::all()` 
- `Equip::findOrFail($id)` 
- `Equip::create($data)` 
- `$equip->update($data)` 
- `Equip::destroy($id)`

Si demÃ  canvies Eloquent per una API externa o per SQL â€œa pÃ¨lâ€, el lloc on tocar quasi sempre serÃ  el *repository*, no tota lâ€™aplicaciÃ³.

---

### ğŸ§  QuÃ¨ Ã©s un *Service* (`EquipService`)?

El **service** Ã©s on posem la **lÃ²gica de negoci** dâ€™un domini concret (equips, estadis, comandes, etc.).

- No tracta amb HTTP directament. 
- No parla directament amb Eloquent. 
- Parla amb el **repository**.

Exemple:

```php
class EquipService {
    public function __construct(private EquipRepository $repo) {}

    public function llistar() {
        return $this->repo->getAll();
    }

    public function trobar($id){
        return $this->repo->find($id);
    }

    public function guardar(array $data) {
        // AcÃ­ podrÃ­em fer comprovacions abans de guardar
        return $this->repo->create($data);
    }

    public function actualitzar($id, array $data) {
        return $this->repo->update($id, $data);
    }

    public function eliminar($id) {
        return $this->repo->delete($id);
    }
}
```

El **controller** li demana coses al *service*:

- â€œLlistaâ€™m els equipsâ€ 
- â€œGuarda aquest equip nouâ€ 
- â€œActualitza aquest equipâ€ 
- â€œEsborraâ€™lâ€

El *service* decideix com fer-ho i utilitza el *repository*.

---

### ğŸ”Œ QuÃ¨ Ã©s un *ServiceProvider* (registrar el repository)?

Laravel tÃ© un â€œcontenidorâ€ intern que sâ€™encarrega de crear objectes i injectar-los als constructors.

Quan escrius:

```php
public function __construct(BaseRepository $repo)
```

Laravel es pregunta:

> â€œQuina classe concreta he de crear per a omplir aquest `BaseRepository`?â€

AixÃ² li ho indiquem en un **ServiceProvider**, per exemple a `App\Providers\AppServiceProvider`:

```php
use App\Repositories\BaseRepository;
use App\Repositories\EquipRepository;

public function register(): void
{
    $this->app->bind(BaseRepository::class, EquipRepository::class);
}
```

TraducciÃ³:

> â€œQuan algÃº em demane un `BaseRepository`, jo li done un `EquipRepository`.â€

AixÃ² ens permet injectar la **interface** `BaseRepository` al `EquipService`, 
i Laravel ja sâ€™encarrega dâ€™injectar-li un `EquipRepository`.

---

## 2ï¸âƒ£ AplicaciÃ³ concreta a la prÃ ctica

Ara apliquem tot aixÃ² al nostre projecte de **futbol femenÃ­**.

El que volem fer Ã©s:

1. **Crear Interface** â†’ `BaseRepository` 
2. **Crear Repository** â†’ `EquipRepository` 
3. **Registrar Repository** â†’ al `ServiceProvider` 
4. **Crear Service** â†’ `EquipService` 
5. Fer que el `EquipController` utilitze el **service**.

---

### 4. ğŸ“¦ Repository i controlador per a equips

#### 4.1. Crear Interface: `BaseRepository`

ğŸ“„ `app/Repositories/BaseRepository.php`

```php
<?php

namespace App\Repositories;

interface BaseRepository {
    public function getAll();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}
```

AixÃ² Ã©s el contracte que desprÃ©s implementarÃ  `EquipRepository`.

---

#### 4.2. Crear Repository: `EquipRepository`

ğŸ“„ `app/Repositories/EquipRepository.php`

```php
<?php

namespace App\Repositories;

use App\Models\Equip;

class EquipRepository implements BaseRepository {
    public function getAll() {
        return Equip::all();
    }

    public function find($id) {
        return Equip::findOrFail($id);
    }

    public function create(array $data) {
        return Equip::create($data);
    }

    public function update($id, array $data) {
        $equip = Equip::findOrFail($id);
        $equip->update($data);
        return $equip;
    }

    public function delete($id) {
        return Equip::destroy($id);
    }
}
```

Ara tot lâ€™accÃ©s a la taula `equips` estÃ  concentrat acÃ­.

---

#### 4.3. Registrar Repository: `AppServiceProvider`

ğŸ“„ `app/Providers/AppServiceProvider.php`

Afegim al principi:

```php
use App\Repositories\BaseRepository;
use App\Repositories\EquipRepository;
```

I dins del mÃ¨tode `register()`:

```php
public function register(): void
{
    $this->app->bind(BaseRepository::class, EquipRepository::class);
}
```

A partir dâ€™ara, quan el contenidor de Laravel veja que algun lloc demana un `BaseRepository`, instanciarÃ  un `EquipRepository`.

---

### 5. ğŸ§  Crear Service: `EquipService`

Ara creem el service dâ€™equips.

ğŸ“„ `app/Services/EquipService.php`

```php
<?php

namespace App\Services;

use App\Repositories\BaseRepository;

class EquipService {
    public function __construct(private BaseRepository $repo) {}

    public function llistar() {
        return $this->repo->getAll();
    }

    public function trobar($id){
        return $this->repo->find($id);
    }

    public function guardar(array $data) {
        return $this->repo->create($data);
    }

    public function actualitzar($id, array $data) {
        return $this->repo->update($id, $data);
    }

    public function eliminar($id) {
        return $this->repo->delete($id);
    }
}
```

AcÃ­ el `EquipService` **no sap** que hi ha un `EquipRepository` concret. 
NomÃ©s sap que tÃ© un `BaseRepository` que pot fer `getAll`, `find`, `create`, `update`, `delete`.

GrÃ cies al `bind` del ServiceProvider, Laravel li injectarÃ  un `EquipRepository`.

---

### 5.1. Fer servir el Service des del `EquipController`

Finalment, fem que el controlador utilitze el service en lloc dâ€™anar directe a Eloquent.

ğŸ“„ `app/Http/Controllers/EquipController.php`

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreEquipRequest;
use App\Http\Requests\UpdateEquipRequest;
use App\Models\Equip;
use App\Models\Estadi;
use App\Services\EquipService;

class EquipController extends Controller
{
    public function __construct(private EquipService $servei) {}

    // GET /equips
    public function index() {
        $equips = $this->servei->llistar();
        return view('equips.index', compact('equips'));
    }

    // GET /equips/create
    public function create() {
        $estadis = Estadi::all();
        return view('equips.create', compact('estadis'));
    }

    // POST /equips
    public function store(StoreEquipRequest $request) {
        $this->servei->guardar($request->validated());
        return redirect()->route('equips.index');
    }

    // GET /equips/{equip}
    public function show(Equip $equip) {
        return view('equips.show', compact('equip'));
    }

    // GET /equips/{equip}/edit
    public function edit(Equip $equip) {
        return view('equips.edit', compact('equip'));
    }

    // PUT /equips/{equip}
    public function update(UpdateEquipRequest $request, Equip $equip) {
        $this->servei->actualitzar($equip->id, $request->validated());
        return redirect()->route('equips.index');
    }

    // DELETE /equips/{equip}
    public function destroy(Equip $equip) {
        $this->servei->eliminar($equip->id);
        return redirect()->route('equips.index');
    }
}
```

Ara el flux complet dâ€™un CRUD dâ€™equip Ã©s:

```text
[HTTP] â†’ EquipController
            â†“
       EquipService
            â†“
   BaseRepository (interface)
            â†“
     EquipRepository (Eloquent)
            â†“
        Model Equip
            â†“
        Base de dades
```

---

### 5.2. Resum curt per a lâ€™alumnat

- **Interface `BaseRepository`** 
  Contracte amb els mÃ¨todes bÃ sics: `getAll`, `find`, `create`, `update`, `delete`.

- **`EquipRepository`** 
  Implementa aquest contracte per al model `Equip` usant Eloquent.

- **`AppServiceProvider`**
  Registra que `BaseRepository` correspon a `EquipRepository`.

- **`EquipService`**
  ContÃ© la lÃ²gica dâ€™equips i utilitza el repositori.

- **`EquipController`**
  Rep la peticiÃ³ HTTP, parla amb el service i retorna vistes.

AixÃ­ aconseguim controladors mÃ©s nets i un projecte que pot crÃ©ixer millor, amb les responsabilitats ben separades.